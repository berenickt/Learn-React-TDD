# 1. 테스트 코드의 비밀

1. 한 번 작성된 테스트 코드는 영원히 유지보수해야 한다.
2. 내부 구현사항을 테스트하지 않는다.
3. 재사용성을 높이기 (별도의 테스트 클래스, 테스트 유틸리티)
4. 배포용 코드와 철저히 분리하기
5. 테스트 코드를 통한 문서화

---

# 2. 좋은 테스트 구조

1. Before
   - beforeEach
   - beforeAll
2. After
   - afterEach
   - afterAll

---

## 2.1 구조

테스트의 구조를 3A라고도 부릅니다.

1. 준비(Arrange)
2. 실행(Act)
3. 검증(Assert)

또는 GWT라고도 부릅니다.

1. `Given(무언가 주어졌을 떄)` : 준비과정을 재사용
2. `When(코드가 실행될 떄)` : 의도적으로 실패하기
3. `Then(그러면 이렇게 예상)` : 가장 마지막에

---

# 3. 좋은 테스트의 원칙

FIRST

(Fast, Isolated, Repeatable, Self-Validation, Timey)

1. `Fast`
   - **느린 것에 대한 의존성 낮추기**
   - e.g. 파일, DB, 네트워크
   - Mock이나 Stub을 사용
2. `Isolated`
   - **최소한의 유닛으로 검증하기**
   - 독립적이고, 집중적으로 유지
3. `Repeatable`
   - 실행할 때마다 동일한 결과를 유지
   - 환경에 영향을 받지 않도록 작성
4. `Self-Validation`
   - 스스로 결과를 검증하기
   - 자동화를 통한 검증단계 (CI/CD)
5. `Timely`
   - 시기적절하게 테스트 코드 작성
   - 사용자에게 배포되기 이전에 테스트 코드 작성

---

# 4. 무엇을 테스트할지 모를 떄의 원칙

Right-BICEP

1. `Right`
   - 모든 요구사항이 정상동작하는지 확인
   - 모든 결과가 정확한지 확인
2. `Boundary conditions`
   - 모든 코너 케이스에 대해 테스트하기
   - 잘못된 포맷의 인풋, null, 특수문자, 잘못된 이메일, 작은 숫자, 큰 숫자, 중복, 순서가 맞지 않음
3. `Inverse relationship`
   - 역관계를 적용해서 결과값을 확인
   - 일관성을 유지(덧셈 -> 뺄셈, 추가 -> 제거)
4. `Cross-check`
   - 다른 수단을 이용해서 결과값이 맞는지 확인
   - 추가된 과일 == 전체과일 - 예전의 과일 갯수
   - A알고리즘 == B알고리즘
5. `Error conditions`
   - 불행한 경로에 대해 우아하게 처리하는가?
   - 네트워크 에러, 메모리 부족, 데이터 중지, ...
6. `Performance characteristics`
   - 성능 확인은 테스트를 통해 정확한 수치로 확인
   - 성능 개선의 척도와 확인은 데이터를 통해 확인

---

# 5. 좋은 테스트의 커버리지(Coverage, 적용 범위)

## 5.1 테스트의 조건

CORRECT

1. `Conformance`
   - 특정 포맷을 준수
   - e.g. 전화번호, 이메일, 아이디, 파일 확장자, ...
2. `Ordering`
   - 순서 조건 확인하기
   - 순서가 중요한 경우
3. `Range`
   - 숫자의 범위
   - 제한된 범위보다 작거나 큰 경우
4. `Reference`
   - 외부 의존성 유무, 특정한 조건의 유무
   - ~일떄, ~가 되어있을 떄, 어떤 특정 상황/상태일떄 이런 동작을 한다.
5. `Existence`
   - 값이 존재하지 않을 떄 어떻게 도작?
   - null, undefined, '', 0
6. `Cardinality`
   - 0-1-N 법칙에 따라 검증
   - 하나도 없을떄, 하나만 있을 떄, 여러 개가 있을떄
7. `Time`
   - 상대, 절대, 동시의 일들
   - 순서가 맞지 않은 경우, 소비한 시간, 지역 시간
